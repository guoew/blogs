## 一. 概述
在lua中，字符串实际上是被内化的一种数据。在每个存放lua字符串的变量，实际上是对对字符串数据的引用，每当新建一个字符串，都会去检查当前系统中是否已经存在相同数据的字符串了，如果存在直接复用，将引用指向存在的字符串数据，否则新建字符串数据。
因此，字符串在lua中为不可变数据，改变引用变量指向位置并不影响原来字符串数据，如下代码中
```lua
a = "1"
a = a .. "2"
```
第一行代码创建了一个变量a,指向字符串"1",第二行代码对变量a重新修改，指向字符串"12"(a + "2")，并没有影响字符串"1"。换言之，此时系统中存在两个字符串："1"和"12"，字符串"1"如果其他地方没有引用的话，将会在GC阶段被回收。

所以，在lua中多份相同的字符串在整个系统中只存在一个人副本，与此带来的缺陷就是在创建新的字符串时，首先会检查系统中是否存在相同的数据，不存在才创建，这与直接创建字符串相比，多了一次查找的过程。

以上内容总结如下：
> 1. 在lua虚拟机中存在一个全局的数据区，存放当前系统中所有字符串
> 2. 同一字符串数据，在lua虚拟机只可能存在一份副本，字符串一旦创建，将不可变更
> 3. 变量存放的字符串的引用，而不是其实际内容

## 二. 字符串实现
字符串以散列桶来存放数据，字符串创建过程中实现逻辑如下
1. 计算新建字符串对应散列值
2. 根据散列值找到对应散列桶，遍历该桶所有元素，如果能够查到同样的字符串，直接返回
3. 如果第2步查不到相同的字符串新建一个字符串
   
如上，在lua中，应尽量避免使用字符串连接操作符，因为每次都会生成一个新的字符串，比如下面两段实现同样功能的代码(出自Lua Programming Gems一书的第2章 "Lua Performance Tips")
```lua
a = os.clock()
local s = ""
for i = 1,300000 do
    s = s .. "a"
    -- .. 为字符串连接符
end
b = os.clock()
print(b-a) --4.937
```
这段代码使用字符串连接操作符来生成新的字符串
```lua
a = os.clock()
local s = ""
local t = {}
for i = 1,300000 do
    t[#t + 1] = a
    -- #t用来捕获连续数组最大的key值，lua中table key值从1开始计数
end
s = table.concat(t,"")
--[[
    table.concat(table,seq,start,end)
    concat是concatenate(连锁,连接)的缩写，table.concat()函数列出参数中指定table中的连续数组部分从start位置到end位置的所有元素，元素间以指定的分隔符隔开，除table外，其他参数都不是必须的，分隔符的默认值为空字符串，start默认为1，end默认为数组总长。
    扩展:
    table.insert(table,pos,value)
    table.insert()函数在table的数组部分指定位置插入值为value的元素，pos可选，默认数组部分末尾
]] 
b = os.clock()
print(b-a) --0.24
```
这种做法使用table模拟字符串缓存区，避免了大量使用字节操作符，性能比第一段提升20倍。

----
笔记来自《lua设计与实现》  